# Algorithm
This is an auto push repository for Baekjoon Online Judge created with [BaekjoonHub](https://github.com/BaekjoonHub/BaekjoonHub).

---

<details>
<summary><b>플로이드 워셜 (Floyd-Warshall)</b></summary><br>


**개념**

모든 정점 쌍 사이의 최단 거리를 구하는 알고리즘

**시간복잡도**
- 시간: O(V³)
- 공간: O(V²)

**동작방법**
1. 거리 테이블을 INF로 초기화 (자기 자신은 0)
2. 직접 연결된 간선 정보로 테이블 초기화
3. 각 정점 k를 거쳐가는 경로 고려
   - k=1일 때: 1번 정점을 거쳐가는 최단 경로 갱신
   - k=2일 때: 1,2번 정점을 거쳐가는 최단 경로 갱신
   - ...
   - k=V일 때: 모든 정점을 거쳐가는 최단 경로 갱신
4. D[i][j] = min(D[i][j], D[i][k] + D[k][j])로 갱신

**증명**

k=1일 때 중간에 다른 정점을 거치지 않았거나 1번 정점을 거쳐서 갈 때의 최단 거리를 알 수 있고, 그 다음으로 중간에 다른 정점을 거치지 않았거나 1,2번 정점을 거쳐서 갈 떄의 최단 거리를 알 수 있다는 식의 귀납법

**핵심 아이디어**
- "중간에 k번 정점을 거쳐가면 더 짧아질까?"를 모든 정점 쌍에 대해 확인
- k번 정점을 거쳐가는 것이 유리하면: i→k→j 경로로 갱신

**STANDARD 문제**
- [BOJ 11780](https://www.acmicpc.net/problem/11780): 플로이드 2 [(최단 거리 + 경로 복원)](../백준/Gold/11780.%E2%80%85플로이드%E2%80%852/플로이드%E2%80%852.java)


**주의사항**
- 방향 그래프, 무방향 그래프, 간선 값이 음수인 그래프 모두 가능
- 음수 사이클이 있으면 제대로 작동하지 않음
- **3중 for문 순서 중요**: k(거쳐가는 정점)가 반드시 가장 바깥에 위치
- INF 값 설정: 두 INF를 더해도 오버플로우 나지 않도록 `0x3f3f3f3f` 권장
- 정점이 적을 때(V ≤ 500~1000) 사용 가능
- 상수 최적화: `dist[i][j] = min(...)`보다 `if`문으로 비교 후 대입이 더 빠름

</details>
